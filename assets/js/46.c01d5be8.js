(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{465:function(v,e,_){"use strict";_.r(e);var t=_(53),a=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"_8-vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue"}},[v._v("#")]),v._v(" 8. Vue")]),v._v(" "),_("h3",{attrs:{id:"_1-vdom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vdom"}},[v._v("#")]),v._v(" 1. vdom")]),v._v(" "),_("p",[v._v("a. 用 JS 模拟 DOM 结构，提高重绘性能")]),v._v(" "),_("p",[v._v("b. DOM 操作非常昂贵，DOM 操作放在 js，提高效率")]),v._v(" "),_("p",[v._v("c.vdom 的核心 API 是"),_("code",[v._v("h、patch")])]),v._v(" "),_("h3",{attrs:{id:"_2-vue-编译原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-编译原理"}},[v._v("#")]),v._v(" 2. Vue 编译原理")]),v._v(" "),_("p",[v._v("parse-optimize-generate")]),v._v(" "),_("p",[v._v("源码编译篇思维导图")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/assets/vue-source-code1.jpg")}}),v._v(" "),_("p",[v._v("源码响应篇思维导图")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/assets/vue-source-code2.png")}}),v._v(" "),_("h3",{attrs:{id:"_3-vue-的-nexttick-实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-的-nexttick-实现"}},[v._v("#")]),v._v(" 3. Vue 的 nextTick 实现")]),v._v(" "),_("p",[v._v("对于 "),_("code",[v._v("macro task")]),v._v("的实现，优先检测是否支持原生 "),_("code",[v._v("setImmediate")]),v._v("，这是一个高版本 "),_("code",[v._v("IE")]),v._v(" 和 "),_("code",[v._v("Edge")]),v._v(" 才支持的特性，不支持的话再去检测是否支持原生的 "),_("code",[v._v("MessageChannel")]),v._v("，如果也不支持的话就会降级为 "),_("code",[v._v("setTimeout 0")]),v._v("；而对于"),_("code",[v._v("micro task")]),v._v(" 的实现，则检测浏览器是否原生支持 "),_("code",[v._v("Promise")]),v._v("，不支持的话直接指向 "),_("code",[v._v("macro task")]),v._v(" 的实现。")]),v._v(" "),_("h3",{attrs:{id:"_4-vue-的模板如何被渲染成-html-及渲染过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-的模板如何被渲染成-html-及渲染过程"}},[v._v("#")]),v._v(" 4. Vue 的模板如何被渲染成 html 及渲染过程")]),v._v(" "),_("p",[v._v("a.解析模板变成 render 函数")]),v._v(" "),_("p",[v._v("b.响应式监听")]),v._v(" "),_("p",[v._v("c.执行 render 函数生成 vnode，首次渲染，显示页面且绑定依赖")]),v._v(" "),_("p",[v._v("d.data 属性变化，触发 rerender")]),v._v(" "),_("h3",{attrs:{id:"_5-vue-的更新过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-的更新过程"}},[v._v("#")]),v._v(" 5. Vue 的更新过程")]),v._v(" "),_("p",[v._v("当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程，这个过程又利用了队列做了进一步优化，在 nextTick 后执行所有 watcher 的 run，最后执行它们的回调函数。")]),v._v(" "),_("h3",{attrs:{id:"_6-vue-key-的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-key-的作用"}},[v._v("#")]),v._v(" 6. Vue key 的作用")]),v._v(" "),_("ol",[_("li",[v._v("给出结论，key 的作用是用于优化 patch 性能")]),v._v(" "),_("li",[v._v("key 的必要性")]),v._v(" "),_("li",[v._v("实际使用方式")]),v._v(" "),_("li",[v._v("总结：可从源码层面描述一下 vue 如何判断两个节点是否相同")])]),v._v(" "),_("p",[v._v("详细：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("key 的作用主要是为了更高效的更新虚拟 DOM。")])]),v._v(" "),_("li",[_("p",[v._v("vue 在 patch 过程中"),_("strong",[v._v("判断两个节点是否是相同节点是 key 是一个必要条件")]),v._v("，渲染一组列表时，key 往往是唯一标识，所以如果不定义 key 的话，vue 只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。")])]),v._v(" "),_("li",[_("p",[v._v("实际使用中在渲染一组列表时 key 必须设置，而且必须是唯一标识，应该避免使用数组索引作为 key，这可能导致一些隐蔽的 bug；vue 中在使用相同标签元素过渡切换时，也会使用 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。")])]),v._v(" "),_("li",[_("p",[v._v("从源码中可以知道，vue 判断两个节点是否相同时主要判断两者的 key 和元素类型等，因此如果不设置 key，它的值就是 undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的 dom 更新操作，明显是不可取的。")])]),v._v(" "),_("li",[_("p",[v._v("带 key 和不带 key 会影响 diff 算法的具体操作，例如：A B C 要更新为 B A C，不带 key 的操作是：A 更新为 B，B 更新为 A，带 key 的操作则会直接移动 A B 节点，减少删除新增 DOM 的消耗。")])])]),v._v(" "),_("h3",{attrs:{id:"_7-vue-双向绑定以及它的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-双向绑定以及它的实现原理"}},[v._v("#")]),v._v(" 7. Vue 双向绑定以及它的实现原理？")]),v._v(" "),_("ol",[_("li",[v._v("给出双绑定义")]),v._v(" "),_("li",[v._v("双绑带来的好处")]),v._v(" "),_("li",[v._v("在哪使用双绑")]),v._v(" "),_("li",[v._v("使用方式")]),v._v(" "),_("li",[v._v("扩展：使用细节、原理实现描述")])]),v._v(" "),_("p",[v._v("详细：")]),v._v(" "),_("ol",[_("li",[v._v("vue 中双向绑定是一个指令 v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model 是语法糖，默认情况下相当于:value 和@input。")]),v._v(" "),_("li",[v._v("使用 v-model 可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好")]),v._v(" "),_("li",[v._v("通常在表单项上使用 v-model")]),v._v(" "),_("li",[v._v("原生的表单项可以直接使用 v-model，自定义组件上如果要使用它需要在组件内绑定 value 并处理输入事件")]),v._v(" "),_("li",[v._v("我做过测试，输出包含 v-model 模板的组件渲染函数，发现它会被转换为 value 属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是 vue 的编译器完成的。")])]),v._v(" "),_("h3",{attrs:{id:"_8-vue-中的-diff-算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-中的-diff-算法"}},[v._v("#")]),v._v(" 8. Vue 中的 diff 算法")]),v._v(" "),_("ol",[_("li",[v._v("定义 diff")]),v._v(" "),_("li",[v._v("它的必要性")]),v._v(" "),_("li",[v._v("它在哪里被使用")]),v._v(" "),_("li",[v._v("它如何运作")]),v._v(" "),_("li",[v._v("提升：说一些细节")])]),v._v(" "),_("p",[v._v("详细：")]),v._v(" "),_("ol",[_("li",[v._v("diff 算法是虚拟 DOM 技术的产物，vue 里面实际叫做 patch，它的核心实现来自于 snabbdom（核心 API:"),_("code",[v._v("h、patch")]),v._v("）；通过新旧虚拟 DOM 作对比（即 patch），将变化的地方转换为 DOM 操作")]),v._v(" "),_("li",[v._v("在 vue 1 中是没有 patch 的，因为界面中每个依赖都有专门的 watcher 负责更新，这样项目规模变大就会成为性能瓶颈，vue 2 中为了降低 watcher 粒度，每个组件只有一个 watcher，但是当需要更新的时候，怎样才能精确找到发生变化的地方？这就需要引入 patch 才行。")]),v._v(" "),_("li",[v._v("组件中数据发生变化时，对应的 watcher 会通知更新并执行其更新函数，它会执行渲染函数获取全新虚拟 dom：newVnode，此时就会执行 patch 比对上次渲染结果 oldVnode 和新的渲染结果 newVnode。")]),v._v(" "),_("li",[v._v("patch 过程遵循深度优先、同层比较的策略；两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效。")]),v._v(" "),_("li",[v._v("核心逻辑 "),_("code",[v._v("createElement")]),v._v("和"),_("code",[v._v("updateChildren")]),_("a",{attrs:{href:"https://blog.csdn.net/zemprogram/article/details/101694601",target:"_blank",rel:"noopener noreferrer"}},[v._v("具体解析看这里"),_("OutboundLink")],1)])]),v._v(" "),_("h3",{attrs:{id:"_9-vue-监听-data-每个属性的变化-为什么要监听-get-直接监听-set-为什么不行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-监听-data-每个属性的变化-为什么要监听-get-直接监听-set-为什么不行"}},[v._v("#")]),v._v(" 9. Vue 监听 data 每个属性的变化？为什么要监听 get，直接监听 set 为什么不行？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Object.defineProperty、将 data 代理到 vm 上")])]),v._v(" "),_("li",[_("p",[v._v("因为 data 中有很多属性，有的被用到，有的没有被用到，监听 get 是避免 set 的时候判断是否需要重新渲染 dom，优化性能")])])]),v._v(" "),_("h3",{attrs:{id:"_10-vue-的模板如何解析-指令如何处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-的模板如何解析-指令如何处理"}},[v._v("#")]),v._v(" 10. Vue 的模板如何解析，指令如何处理？")]),v._v(" "),_("p",[v._v("模板本质是字符串，嵌入逻辑和变量，必须转换为 JS（有逻辑、变量、html），render 函数返回 vnode，最后 updateComponent")]),v._v(" "),_("h3",{attrs:{id:"_11-vue-常见的性能优化方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-常见的性能优化方式"}},[v._v("#")]),v._v(" 11. Vue 常见的性能优化方式")]),v._v(" "),_("ol",[_("li",[v._v("合理使用 v-show 和 v-if")]),v._v(" "),_("li",[v._v("合理使用 computed")]),v._v(" "),_("li",[v._v("v-for 加 key，避免和 v-if 同时使用")]),v._v(" "),_("li",[v._v("自定义事件、DOM 事件及时销毁")]),v._v(" "),_("li",[v._v("合理使用 keep-alive")]),v._v(" "),_("li",[v._v("合理使用异步组件")]),v._v(" "),_("li",[v._v("data 层级不要嵌套过深")]),v._v(" "),_("li",[v._v("合理使用 v-once /v-cloak(配合 diaplay:none 使用)")])]),v._v(" "),_("h3",{attrs:{id:"_12-vuex-理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-vuex-理解"}},[v._v("#")]),v._v(" 12. Vuex 理解")]),v._v(" "),_("ol",[_("li",[v._v("首先给 vuex 下一个定义")]),v._v(" "),_("li",[v._v("vuex 解决了哪些问题，解读理念")]),v._v(" "),_("li",[v._v("什么时候我们需要 vuex")]),v._v(" "),_("li",[v._v("你的具体用法")]),v._v(" "),_("li",[v._v("简述原理，提升层级")])]),v._v(" "),_("p",[v._v("首先是官网定义：")]),v._v(" "),_("blockquote",[_("p",[v._v("Vuex 是一个专为 Vue.js 应用程序开发的"),_("strong",[v._v("状态管理模式")]),v._v("。它采用"),_("strong",[v._v("集中式")]),v._v("存储管理应用的所有组件的状态，并以相应的规则保证状态以一种"),_("strong",[v._v("可预测")]),v._v("的方式发生变化。")])]),v._v(" "),_("p",[v._v("详细：")]),v._v(" "),_("ol",[_("li",[v._v("vuex 是 vue 专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。")]),v._v(" "),_("li",[v._v("vuex 主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。vuex 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。")]),v._v(" "),_("li",[v._v("vuex 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用 vuex 的必要。一个简单的"),_("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8",target:"_blank",rel:"noopener noreferrer"}},[v._v("store 模式"),_("OutboundLink")],1),v._v("就足够了。反之，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。")]),v._v(" "),_("li",[v._v("我在使用 vuex 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 state 对象中，它本身一棵状态树，组件中使用 store 实例的 state 访问这些状态；然后有配套的 mutation 方法修改这些状态，并且只能用 mutation 修改状态，在组件中调用 commit 方法提交 mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写 action，执行结束如果有状态修改仍然需要提交 mutation，组件中调用这些 action 使用 dispatch 方法派发。最后是模块化，通过 modules 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置 namespace，那么在提交 mutation 和派发 action 时还需要额外的命名空间前缀。")]),v._v(" "),_("li",[v._v("vuex 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了 vue 的数据响应化特性实现的，它会利用 Vue 将 state 作为 data 对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);