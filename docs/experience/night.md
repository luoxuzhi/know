## 9. 总结

### 1. koa 框架 await 实现原理

use 的时候把中间推到一个中间件数组，核心方法是 compose(this.middleware) 返回一个 promise，处理完毕后再执行 handleResponse，compose 的核心方法是返回一个函数，函数的核心是返回 dispatch 函数

### 2. node 异步任务怎么执行

node.js 的异步机制是基于事件的，所有的 I/O、网络通信、数据库查询都以非阻塞的方式执行，返回结果由事件循环来处理。node.js 在同一时刻只会处理一个事件，完成后立即进入事件循环检查后面事件。这样 CPU 和内存在同一时间集中处理一件事，同时尽量让耗时的 I/O 等操作并行执行。
[链接](https://blog.csdn.net/fengqiaojiangshui/article/details/55819930)

### 3. Vue 编译原理

parse-optimize-generate

源码编译篇思维导图

<img :src="$withBase('/assets/vue-source-code1.jpg')">

源码响应篇思维导图

<img :src="$withBase('/assets/vue-source-code2.png')">

### 4. http 缓存、强缓存、协商缓存

强制缓存时，服务端会在 Response Headers 中的 cache-control 对缓存时间、缓存方式等进行定义

协商缓存主要表现在 Response Headers 中的 etag 和 last-modified，在客户端重新向服务端发起请求时，会在 Request Headers 中换个 key 名：if-none-matched 和 if-modified-since

两种缓存的共同点：都从客户端缓存中读取资源；区别是强缓存不会向服务器发请求，协商缓存会发请求

### 5. cdn 快的原理

[lianjie](https://www.west.cn/docs/52026.html)

DN 网络由一个 DNS 服务器和几台缓存服务器组成：

- 当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。

* CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回给用户。

* 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。

* CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。

区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户 IP 地址，判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。

基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。全局负载均衡设备把服务器的 IP 地址返回给用户。

用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

### 6. 打包优化

用 Happypack 来加速代码构建，dll，uglify 优化

### 7. Vue 的 nextTick 实现

对于 `macro task`的实现，优先检测是否支持原生 `setImmediate`，这是一个高版本 `IE` 和 `Edge` 才支持的特性，不支持的话再去检测是否支持原生的 `MessageChannel`，如果也不支持的话就会降级为 `setTimeout 0`；而对于`micro task` 的实现，则检测浏览器是否原生支持 `Promise`，不支持的话直接指向 `macro task` 的实现。

### 8. 浏览器 `setTimeout` 怎么判断 5s，事件堆栈放在哪里

在现有浏览器环境中，Javascript 执行引擎是单线程的，主线程的语句和方法，会阻塞定时任务的运行，在 Javascript 执行引擎之外，存在一个任务队列，

当在代码中调用 `setTimeout()`方法时，`注册的延时方法会挂到浏览器内核其他模块处理，当延时方法到达触发条件，即到达设置的延时时间时，该模块再将要执行的方法添加至该模块的任务队列中`。

这一过程与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，才会从该模块的任务队列中顺序提取任务来执行，这期间的时间，可能大于注册任务时设置的延时时间；浏览器在空闲状态下，会不断的尝试从模块的任务队列中提取任务，这称为`事件循环模型`。

`基本类型的数据存储到栈内存（stack）中，引用数据类型存储到堆内存(heap)中；[对象、数组，函数]`

### 10. Vue 的更新过程

Vue 数据修改派发更新的过程也有了认识，实际上就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程，这个过程又利用了队列做了进一步优化，在 nextTick 后执行所有 watcher 的 run，最后执行它们的回调函数。

### 11. 数值转换,一元运算符 +

```js
const age = +'22' // 22
let text2 = '1' + 2 // "12"
let text3 = 1 + '2' // "12"
let text4 = 1 + 2 + '3' // "33"
let num = +text1 //  12 转换为 Number 类型
```

### 12. Vue key 的作用

1. 给出结论，key 的作用是用于优化 patch 性能
2. key 的必要性
3. 实际使用方式
4. 总结：可从源码层面描述一下 vue 如何判断两个节点是否相同

详细：

1. key 的作用主要是为了更高效的更新虚拟 DOM。
2. vue 在 patch 过程中**判断两个节点是否是相同节点是 key 是一个必要条件**，渲染一组列表时，key 往往是唯一标识，所以如果不定义 key 的话，vue 只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。
3. 实际使用中在渲染一组列表时 key 必须设置，而且必须是唯一标识，应该避免使用数组索引作为 key，这可能导致一些隐蔽的 bug；vue 中在使用相同标签元素过渡切换时，也会使用 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。
4. 从源码中可以知道，vue 判断两个节点是否相同时主要判断两者的 key 和元素类型等，因此如果不设置 key，它的值就是 undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的 dom 更新操作，明显是不可取的。

### 14. Vue 双向绑定以及它的实现原理吗？

1. 给出双绑定义
2. 双绑带来的好处
3. 在哪使用双绑
4. 使用方式
5. 扩展：使用细节、原理实现描述

详细：

1. vue 中双向绑定是一个指令 v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model 是语法糖，默认情况下相当于:value 和@input。
2. 使用 v-model 可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好
3. 通常在表单项上使用 v-model
4. 原生的表单项可以直接使用 v-model，自定义组件上如果要使用它需要在组件内绑定 value 并处理输入事件
5. 我做过测试，输出包含 v-model 模板的组件渲染函数，发现它会被转换为 value 属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是 vue 的编译器完成的。

### 15. Vue 中的 diff 算法

1. 定义 diff
2. 它的必要性
3. 它在哪里被使用
4. 它如何运作
5. 提升：说一些细节

详细：

1. diff 算法是虚拟 DOM 技术的产物，vue 里面实际叫做 patch，它的核心实现来自于 snabbdom；通过新旧虚拟 DOM 作对比（即 patch），将变化的地方转换为 DOM 操作
2. 在 vue 1 中是没有 patch 的，因为界面中每个依赖都有专门的 watcher 负责更新，这样项目规模变大就会成为性能瓶颈，vue 2 中为了降低 watcher 粒度，每个组件只有一个 watcher，但是当需要更新的时候，怎样才能精确找到发生变化的地方？这就需要引入 patch 才行。
3. 组件中数据发生变化时，对应的 watcher 会通知更新并执行其更新函数，它会执行渲染函数获取全新虚拟 dom：newVnode，此时就会执行 patch 比对上次渲染结果 oldVnode 和新的渲染结果 newVnode。
4. patch 过程遵循深度优先、同层比较的策略；两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效。

### 16.Vuex 理解

1. 首先给 vuex 下一个定义
2. vuex 解决了哪些问题，解读理念
3. 什么时候我们需要 vuex
4. 你的具体用法
5. 简述原理，提升层级

首先是官网定义：

> Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用**集中式**存储管理应用的所有组件的状态，并以相应的规则保证状态以一种**可预测**的方式发生变化。

详细：

1. vuex 是 vue 专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。
2. vuex 主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。vuex 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。
3. vuex 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用 vuex 的必要。一个简单的[store 模式](https://cn.vuejs.org/v2/guide/state-management.html#简单状态管理起步使用)就足够了。反之，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。
4. 我在使用 vuex 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 state 对象中，它本身一棵状态树，组件中使用 store 实例的 state 访问这些状态；然后有配套的 mutation 方法修改这些状态，并且只能用 mutation 修改状态，在组件中调用 commit 方法提交 mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写 action，执行结束如果有状态修改仍然需要提交 mutation，组件中调用这些 action 使用 dispatch 方法派发。最后是模块化，通过 modules 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置 namespace，那么在提交 mutation 和派发 action 时还需要额外的命名空间前缀。
5. vuex 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了 vue 的数据响应化特性实现的，它会利用 Vue 将 state 作为 data 对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。
