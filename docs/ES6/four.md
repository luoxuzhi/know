## 4.正则的扩展

1. RegExp构造函数 

RegExp构造函数第一个参数是一个正则对象，那么可以使用**第二个参数**指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。

```js
let newRegExp = new new RegExp(/xyz/ig, 'i') // /xyz/i
```


2. 字符串的正则方法

字符串对象共有4个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。

search返回开始匹配的位置

3.u修饰符

* 点字符

点`.`字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于`0xFFFF`的Unicode字符，点字符不能识别，必须加上`u`修饰符。点（.）是一个特殊字符，代表任意的单个字符，但是行终止符除外。
行终止符有：*U+000A 换行符（\n）、U+000D 回车符（\r）、U+2028 行分隔符（line separator）
U+2029 段分隔符（paragraph separator）*


* Unicode字符表示法

ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。
```js
/\u{61}/.test('a') // false
/\u{61}/u.test('a') // true
```

上面代码表示，如果不加u修饰符，正则表达式无法识别`\u{61}`这种表示法，只会认为这匹配`61`个连续的`u`。

* 量词

使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。

```js
let lc = /\u{3}/.test('uuu')
console.log(lc) // true

let lc = /\u{3}/u.test('uuu')
console.log(lc) // false
```


* 预定义模式

`\S`是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。


* i修饰符

```js
/[a-z]/iu.test('\u212A') // true
```
上面代码中，不加u修饰符，就无法识别非规范的K字符。

* y修饰符

除了u修饰符，ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。
y修饰符与g类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。区别在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

在g、y修饰符中都可以使用lastIndex属性，y修饰符隐含了头部匹配的标志^（即必须从起始位置匹配得到）

4.`flags`属性

ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符

5.`s`修饰符 `dotAll`模式

